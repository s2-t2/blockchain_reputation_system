%%% 3Background / %%%
\chapter{Background} \label{ch:background}
%provide overview of topic that might be unfamiliar to 
%the readers
%\section{Reputation algorithms} \label{sec:sectionlabel}
\section{Graph properties}
A graph, as the name suggests can be used to represent objects and their relationships 
graphically. A graph G is an ordered triple (V,E,$\varphi$$_{G}$) where V is a non empty set
of vertices v, E is a non empty set of edges e that connects two vertices and 
$v \in V, e \in E$. $\varphi$$_{G}$ is an incidence function that assigns pair of vertices
to each edge of the graph G. $\varphi$$_{G}$(e) = uv represents that e is an edge that 
joins vertices u and v. Graph properties can be leveraged to serve as an interaction 
graph of network for reputation system. Each node on the network, v can represent 
individuals and the edges that connect the nodes can represent the relationships 
between those nodes. The edge can have varying weights to represent the strength of 
relationship between the nodes. \cite{bondy1976graph}




%cite graph theories and applications:
%http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.721.3161&rep=rep1&type=pdf
%more concept based on what is needed to know when representing/modeling the network.

%\subsection{EigenTrust}
%EigenTrust is a reputation management algorithm for P2P network that aims to minimize 
%malicious behaviour in the network and is based on the notion of transitive trust.
%i.e. If a peer \textit{i} trusts a peer \textit{j} then all other peers trusted by 
%\textit{j} is also trusted by \textit{i}. 
%In EigenTrust, global reputation of each peer \textit{i} is given by local trust value 
%assigned to peer \textit{i} by other peers and is weighted by the global reputation 
%of assigning peers. 
%A local trust value $s_{ij}$ is calculated by 
%each peer \textit{i} which represents the opinion \textit{i} has of \textit{j}. $s_{ij}$
%is the difference of satisfactory and unsatisfactory transactions peer \textit{i} had 
%with other peers \textit{j}.
%\begin{equation}
%	s_{ij} = sat(i,j) - unsat(i,j) \\ 
%\end{equation}
%where sat(i,j) represents number of satisfactory transactions that \textit{i} had with 
%\textit{j} whereas unsat(i,j) represents number of unsatisfactory transactions. \\
%To prevent malicious peers from assigning arbitrarily high local trust values to 
%other malicious peers, the local trust value is normalized as $c_{ij}$ before aggregating 
%them. 
%\begin{equation}
%	c_{ij} = \frac{max(s_{ij},0)}{\sum_{j}max(s_{ij},0)}
%\end{equation}
%$C_{ij}$ keeps changing depending on the good or bad interaction between peer \textit{i} 
%and peer \textit{j}.
%Based on the local trust value assigned by other peers, each peer has a global trust 
%value that determines their standing in the network. To aggregate the normalized local 
%trust values, the approach used is friend-friend reference where a peer \textit{i} 
%would ask its acquaintances about their opinion about other peers. Trust that 
%peer \textit{i} places in peer \textit{k} by asking his friends can be denoted by 
%$t_{ik}$ as : 
%\begin{equation}
%	t_{ik} = \sum_{j} c_{ij} c_{jk}
%\end{equation}
%Each peer asks other peers about their opinion which is weighted based on how much peer 
%\textit{i} trusts them. 
%If we define C as a matrix $[c_{ij}]$ and $t_{i}$ as a vector containing values 
%$t_{ik}$, then $t_{ik}$ = $C^T\vec{c_{i}}$. This helps a peer get a wider view of 
%the network more than its own experience. This can continue for many nodes until peer 
%\textit{i} asks his friend's friend's and friend's friend can be consulted further to 
%receive a broader view of the network. For \textit{n} nodes, we can represent \textit{t}
%as t = $(C^T)^n c_{i}$. For a large enough value of \textit{n} , trust vector 
%$\vec{t_{i}}$ will converge to same vector for every peer \textit{i} and could give 
%complete view of the network. 
%\textit{t} is the global trust vector where $t_{j}$ quantifies the trust system places in 
%peer \textit{j}. 
%EigenTrust is robust to malicious peers and good for decreasing inauthentic file downloads 
%in a P2P network. However, it doesn't address the issues such as inactive peers, where a 
%peer doesn't download from anywhere else, malicious collectiveness, where malicious peers 
%collude to inflate the trust value. It also doesn't have a way to calculate negative trust 
%and is entirely based on user feedback. \cite{kamvar2003eigentrust}
%
% The approach used for deriving these 
% values are past history and friend-friend reference. 

%cite: http://ilpubs.stanford.edu:8090/562/1/2002-56.pdf
%cite: https://www.cs.indiana.edu/~kapadia/courses/I590-Fall-09/internal/eigentrust.pdf

\subsection{Net flow Rate convergence}
Net flow rate convergence can help to determine anomaly in the network. By looking at how 
fast the net flow converges to zero, it can detect unusual behaviour in the network. 
The flow in a network can be measured by looking at inflow and outflow edges and 
calculating their differences. Inflow edges are all incoming edges in the graph and 
outflow edges are all outgoing edges . (diagram) Net flow convergence rate is the rate at which the net flow converges to the global net flow which is zero. 
Depending upon how fast the net flow in a graph converges to zero, it can be useful to 
detect anomaly.(example diagram) 

%cite: Decentralized Reputation system for transaction network. 
%Net flow convergence is used by (cite) and seems useful in detecting sybil node. 

%\subsection{Binomial Random Walk}

\section{Cryptography}
\subsection{Basic Concepts}
Cryptography offers algorithms to achieve confidentiality, integrity,
authenticity, and non-repudiation. Confidentiality and integrity ensure that
the information being communicated is not disclosed or has been modified to or
by any unauthorized parties. The data is hidden or encrypted such that only the
authorized parties can make sense out of it, i.e. decrypt using the previously
agreed upon key. 

Asymmetric key cryptography makes use of key pairs, private key, known only to
the owner and public key, that can be publicly distributed. It ensures
authenticity, a proof that sender is who he claims to be and non-repudiation,
the sender cannot deny having sent the message. Public key verifies the holder
of the private key and encryption of the message. That paired private key can
only decrypt this encrypted message. One of the significant application of
public key cryptography is Digital Signatures, described in more detail in
section (Blockchain section ..) which is useful in preserving the properties of
authenticity and non repudiation.

A cryptosystem can be seen as a five tuple (P,C,K,E,D) that satisfies the following
conditions: \\ 
P is a finite set of plain texts.  \\
C is a finite set of cipher texts. \\ 
K, 	the keyspace is a finite set of keys \\
E, set of encryption rules $e_k$: P $\Rightarrow$ C \\
D, sete of decrytion rules $d_k$ : C $\Rightarrow$ M. \\
for each k $\in$ K, there is $e_{k}$ $\in$ E and $d_{k} \in$ D such that 
$d_{k}(e_{k}(m))$ = m for every plaintext m $\in$ P. \\

% A cryptosystem shouldn't rely on the privacy of algorithm used to secure the system. 
% According to Kerckhoff's principle, a cryptosystem should be secure even if everything 
% about the system, except the key, is public knowledge. Another encryption method 
% known as public key cryptography makes use of two different keys for encryption 
% and decryption respectively. It uses public key and private key pairs that are related 
% but is hard to deduce one from the other. When sending a message, one might make public 
% the public key to the whole network but the private key must not be known/shared with 
% anyone but the owner himself. 
%Diffie-Hellman key exchange
%encryption, decryption 

\subsection{Hash functions}
Cryptographic hash functions are a one-way function, also known as mathematical
trapdoor function that transforms an input message into a fixed length binary
output. It is one way because although converting a message input to a hash
value or a message digest can be done in constant time, reversing the operation
is practically impossible to achieve as its computationally inefficient.
Earlier hash functions include MD5 which produces a 128-bit hash value but is
vulnerable and can be cracked by brute force attack.  The predecessors hash
functions are sha-256 preceeded by sha-1, sha-2 and others. Their applications
include the digital signature, message authentication both of which are
interesting for blockchain as will be discussed in section(name). The essential
characteristics of hash functions are their deterministic output, meaning given
a fixed input; it will always generate the same output. It offers collision
resistant property, i.e. it is impossible or extremely rare to get the same
hash value for two different messages.  If m1 and m2 are the message and h(m1)
and h(m2) are hash functions applied to them respectively, collision resistant
ensures that h(m1) != h(m2). Another important characteristic of a hash
function is that the hash value does not indicate the original information that
was hashed thus making it efficient for hiding information.

%deterministic output 
%computationally efficient
%hash collision: collision resistant h(m1) != h(m2)
%hide information
%sha-1, sha-2, sha-256 

\subsection{Digital Signature}
A digital signature acts as an intermediary to prove that an entity A, has the
password without ever requiring A to reveal it. To create a digital signature,
one would need to apply signing algorithm to the private key along with the
message. Likewise, anyone can verify the generated signature by applying it to
a verification algorithm along with the public key and the message.  If a node
A intends to send a transaction to B on a blockchain network, A needs to prove
that he is the rightful owner of the public address from where the message
originated.  This is done by creating a digital signature using A's private key
from the transaction message. Once the transaction is broadcasted, any node in
the network can verify that signature corresponds with A's public key. The
signature is dependent on the message, and thus any attempt by a malicious node
on the network to modify the message will refute the signature. 

%figure showing basic process

% \subsection{Proof-Of-Work}
% solve a computationally expensive problem and show a proof before being able to do 
% something on the network. 

\section{Blockchain Technology}
Blockchain Technology is a variant of distributed database on a P2P network. As
the name suggests, it is a chain of blocks where each block consists of a list
of transactions that are collected by validators/miners defined by the network.
The linking and ordering of transactions are also the responsibility of these
defined validators. One of the validators proposes a block that the whole
network can accept or reject. A consensus algorithm(cite) comes into play
during the proposal of a block. If a consensus is reached, then the block is
accepted and refused otherwise. Several consensus mechanisms are discussed in
section(cite). The proposed block is then chained with the rest of the blocks
and linked directly to the block before it. The hash value of the previous
block points to the current block and the current block's hash value will point
to the future block. 

Each block is linked together to a previous block by a hash value(cite figure).
Thus, this chain of blocks is unalterable as altering one block would require
modifying every other previous block in the chain that is linked together. One
could view this order as a singly linked list data structure. The chain of the
block shows the ordering of transactions that met consensus at the given time
whereas transactions chain shows the chain of ownership. i.e., each transaction
that is linked together in a block.



%\cite{pilkington201611}

%\subsection{Basic Concepts}
%transaction, message, signature, broadcast, verify, network, miners, validate, write blocks 

\subsection{Evolution \& Categories}
Bitcoin was the first application that made use of Blockchain technology which
was a peer-to-peer electronic cash system. The major contribution of this
application was solving distributed trust at scale without using a trusted
intermediary. 
Along the dimension of validation and access control(cite), blockchains can be
categorized as a public permissionless system, public permissioned, and private
permissioned. 
\begin{itemize}
	\item Public Permissionless:Anyone can join the network and become a writer
		of the block as long as they can solve a problem or reach the consensus
		that satisfies the underlying protocol. The records are publicly
		available and thus publicly verifiable. 
	\item Public Permissioned: Anyone can still join the network, but a writer
		of the block is known but not necessarily trusted entity. The records
		are publicly verifiable. 
	\item Private Permissioned: This is similar to a Public permissioned
		setting, but the records are not made public and therefore doesn't
		offer public verifiability. This kind of setup is more specific to
		business use-cases where one business doesn't need to know about other
		business policies or customer information etc. 
\end{itemize}
[Paper] provides a detailed discussion on various blockchain types and their
uses.


\subsection{Consensus Mechanisms}
As a distributed database with multiple writers, there has to be a way for
everyone to reach a consensus on a shared global view of the network. Consensus
mechanisms allow doing so. Based on consensus mechanisms, systems can be
distinctly categorized into [Note: taken from hashgraph presentation slides]
\begin{itemize}
	\item Leader Based System: In this case, there is a pre-selected leader
		that collects all the transactions and appends new records to the
		blockchain.  Having a small group or consortium, it has low
		computational requirements. As a blockchain protocol, it offers an
		immutable audit of the records. However, just like any other
		centralized system, this system is susceptible to DDOS attacks and
		third-party(leader) interference. Generally used in a private or
		permissioned blockchain setup, it offers higher throughput compared to
		public permissionless blockchains. Examples include Hyperledger Fabric,
		R3 Corda, IOTA, etc. 
	\item Proof-Of-Work: This is the most widely used consensus mechanism in a
		public permissionless setup. As the name suggests, a validator/miner
		needs to provide the proof to the network that it has done a
		significant amount of work. This work requires miners to invest a
		substantial amount of computational resource. The reason for this is
		that everyone(all miners) compete to be the writer of the next block
		for which they need to solve a cryptographic puzzle. Mainly, they need
		to find a hash value that can be associated with the proposed block.
		The only way to find this value is by brute-forcing. The apparent
		advantage of such consensus mechanism is that it makes the system DDOS
		resistant while offering immutable audit trail and scalability.
		However, miners can still decide upon the order of transactions to
		include in the block although they cannot modify the transaction. As
		such, one could term this as 'unfair' since the transaction doesn't get
		picked up in order of when it was broadcasted to the network. 
	\item Economy based systems: Consensus mechanisms such as Proof-of-stake or
		delegated proof-of-stake can be seen as an economy based system. Unlike
		PoW, miners don't compete with each other to be the writer of next
		block thus saving lots of computational resources. The general idea is
		that participants can put the respective platform based native token
		they own at stake to validate a block. Whoever has the highest value at
		stake gets to write the next block. If the participation turned out to
		be a malicious one, then all the tokens that were at stake get lost. As
		such, it puts scarce resource at stake. However, this includes problem
		such as nothing-at-stake(cite). i.e., a node could vouch for two forks
		of the same blockchain with nothing to lose. Other drawbacks of this
		approach are that there is no certainty of consensus, and often has no
		total ordering of transactions. Examples include Casper, IOTA, etc. 
\end{itemize}

\subsection{Smart contracts}
A contract in a classical sense is a set of rules with pre-defined obligations
and permissions that participants are assumed to follow and bears legal
meaning. A smart contract, however is a computer program that can codify the
interaction between participating entities and self-executes when triggered by
an event. It doesn't necessarily need to be legally binding or even associated
with the outside world. 
\footnote{https://universe.ida.dk/media/23422289/fritz-henglein.pdf}
The term Smart contact was first coined by Cryptographer Nick Szabo, in 1994
\cite{SzaboSmart1994} and defined as a computerized transaction protocol that
can execute the terms of a contract. Szabo points out that the contract
design should fulfill four objectives\cite{szabo1996smart}: \\
\textbf{Observability}, ability to observe the performance of principal(agents
who have agreed to the contract) and prove their performance.\\
\textbf{Verifiability}, the ability of principals to prove to the arbitrators
that the contract has been performed or breached. \\ 
\textbf{Privity}, to ensure that the third party should not have control or
knowledge of the content or performance. It correlates to both privacy and
confidentiality of principals of contract and the contract itself. \\
\textbf{Enforceability}, to make the contract self-enforcing which can be
attributed to by verifiability, built-in incentives mechanism, and objective
mentioned above. \\
Privity refers to minimization of third-party vulnerability by limiting
knowledge and control whereas, on the other end, observability and
verifiability demand invoking it to an extent. As such, a trade-off is
required wherein an optimal balance between these objectives should meet. Thus,
trusted intermediaries were introduced with minimal control/observability.
However, privity was not guaranteed in case of dispute. 
\cite{szabo1997formalizing}.
Following the invention of Bitcoin and several decentralized blockchains, the
definition of smart contracts have evolved. Ethereum being the first platform to
offer programmable blockchains, introduced a virtual machine, EVM, where the
contract code can be executed that results in a deterministic output provided
the same transaction context and blockchain state. 
\footnote{https://github.com/ethereumbook/ethereumbook/blob/develop/smart-contracts.asciidoc}
EVM often referred to as a single world computer runs on every ethereum node
and given the same initial state produces the same final state. Several high
level languages can be used to write smartcontracts for different blockchain
platform. Examples include solidity, serpent, LLL, etc.  For the sake of
relevance to this project, solidity as the smart contract language and Ethereum
as the blockchain will be used as a point of view henceforth. Contract's code
resides in the blockchain as an immutable form.  They are not autonomous
self-executing program but rather needs to be called by a transaction or
invoked by other contracts. Once the code is registered and deployed on the
blockchain, its code cannot be altered by anyone, including the owner of the
contract. However, there exists a possibility to include killable function that
can be executed by the owner which when called executes an EVM opcode called
SELFDESTRUCT and deletes the contract from the blockchain.  As in any
Turing-complete language, solidity is affected by the halting problem.  To
address this, Ethereum introduces the concept of gas. To store any state, or
execute any operation, gas needs to be supplied. Thus, a program that has a bug
or a non-terminating intention will eventually run out of gas and
stop.\cite{whataresmartcontracts} 

\subsection{Applications}




